Program:
MainClass:
:CLASS
Identifier:BinarySearch
LBRACKET:{
:PUBLIC
:STATIC
:VOID
:MAIN
LP:(
:String
LSQUAREP:[
RSQUAREP:]
Identifier:a
RP:)
LBRACKET:{
PrintStatement:
PRINT:System.out.println
LP:(
MethodCallExpression:
NewClassExpression:
NEW:new
Identifier:BS
LP:(
RP:)
PERIOD:.
Identifier:Start
LP:(
INTEGER:20
RP:)
RP:)
SEMICOLON:;
RBRACKET:}
RBRACKET:}
ClassDeclaration:
:CLASS
Identifier:BS
LBRACKET:{
VarDeclarationList:
VarDeclaration:
TypeVector:
Type:INT
LSQUAREP:[
RSQUAREP:]
Identifier:number
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:size
SEMICOLON:;
MethodDeclarationList:
MethodDeclarationList:
MethodDeclarationList:
MethodDeclarationList:
MethodDeclarationList:
MethodDeclaration:
:public
TYPE:int
Identifier:Start
LP:(
ParameterList:
TYPE:int
Identifier:sz
RP:)
LBRACKET:{
VarDeclarationList:
VarDeclaration:
TYPE:int
Identifier:aux01
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:aux02
SEMICOLON:;
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
AssignmentStatement:
Identifier:aux01
EQUALS:=
MethodCallExpression:
:this
PERIOD:.
Identifier:Init
LP:(
Identifier:sz
RP:)
SEMICOLON:;
AssignmentStatement:
Identifier:aux02
EQUALS:=
MethodCallExpressionWithoutArgs:
:this
PERIOD:.
Identifier:Print
LP:(
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:8
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:19
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:20
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:21
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:37
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:38
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:39
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Search
LP:(
INTEGER:50
RP:)
RP:)
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:1
RP:)
SEMICOLON:;
ELSE:else
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:0
RP:)
SEMICOLON:;
:return
INTEGER:999
SEMICOLON:;
RBRACKET:}
MethodDeclaration:
:public
TYPE:boolean
Identifier:Search
LP:(
ParameterList:
TYPE:int
Identifier:num
RP:)
LBRACKET:{
VarDeclarationList:
VarDeclarationList:
VarDeclarationList:
VarDeclarationList:
VarDeclarationList:
VarDeclarationList:
VarDeclaration:
TYPE:boolean
Identifier:bs01
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:right
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:left
SEMICOLON:;
VarDeclaration:
TYPE:boolean
Identifier:var_cont
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:medium
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:aux01
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:nt
SEMICOLON:;
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
AssignmentStatement:
Identifier:aux01
EQUALS:=
INTEGER:0
SEMICOLON:;
AssignmentStatement:
Identifier:bs01
EQUALS:=
LITERAL:false
SEMICOLON:;
AssignmentStatement:
Identifier:right
EQUALS:=
LengthExpression:
Identifier:number
PERIOD:.
LENGTH:length
SEMICOLON:;
AssignmentStatement:
Identifier:right
EQUALS:=
MinusExpression:
Identifier:right
MINUS:-
INTEGER:1
SEMICOLON:;
AssignmentStatement:
Identifier:left
EQUALS:=
INTEGER:0
SEMICOLON:;
AssignmentStatement:
Identifier:var_cont
EQUALS:=
LITERAL:true
SEMICOLON:;
WHILEStatement:
WHILE:while
LP:(
Identifier:var_cont
RP:)
Statement:
LBRACKET:{
StatementList:
StatementList:
StatementList:
StatementList:
StatementList:
AssignmentStatement:
Identifier:medium
EQUALS:=
PlusExpression:
Identifier:left
PLUS:+
Identifier:right
SEMICOLON:;
AssignmentStatement:
Identifier:medium
EQUALS:=
MethodCallExpression:
:this
PERIOD:.
Identifier:Div
LP:(
Identifier:medium
RP:)
SEMICOLON:;
AssignmentStatement:
Identifier:aux01
EQUALS:=
VectorAccessExpression:
Identifier:number
LSQUAREP:[
Identifier:medium
RSQUAREP:]
SEMICOLON:;
IFStatement:
IF:if
LP:(
LESSERExpression:
Identifier:num
LESSER:<
Identifier:aux01
RP:)
AssignmentStatement:
Identifier:right
EQUALS:=
MinusExpression:
Identifier:medium
MINUS:-
INTEGER:1
SEMICOLON:;
ELSE:else
AssignmentStatement:
Identifier:left
EQUALS:=
PlusExpression:
Identifier:medium
PLUS:+
INTEGER:1
SEMICOLON:;
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Compare
LP:(
ExpressionList:
Identifier:aux01
COMMA:,
Identifier:num
RP:)
RP:)
AssignmentStatement:
Identifier:var_cont
EQUALS:=
LITERAL:false
SEMICOLON:;
ELSE:else
AssignmentStatement:
Identifier:var_cont
EQUALS:=
LITERAL:true
SEMICOLON:;
IFStatement:
IF:if
LP:(
LESSERExpression:
Identifier:right
LESSER:<
Identifier:left
RP:)
AssignmentStatement:
Identifier:var_cont
EQUALS:=
LITERAL:false
SEMICOLON:;
ELSE:else
AssignmentStatement:
Identifier:nt
EQUALS:=
INTEGER:0
SEMICOLON:;
RBRACKET:}
IFStatement:
IF:if
LP:(
MethodCallExpression:
:this
PERIOD:.
Identifier:Compare
LP:(
ExpressionList:
Identifier:aux01
COMMA:,
Identifier:num
RP:)
RP:)
AssignmentStatement:
Identifier:bs01
EQUALS:=
LITERAL:true
SEMICOLON:;
ELSE:else
AssignmentStatement:
Identifier:bs01
EQUALS:=
LITERAL:false
SEMICOLON:;
:return
Identifier:bs01
SEMICOLON:;
RBRACKET:}
MethodDeclaration:
:public
TYPE:int
Identifier:Div
LP:(
ParameterList:
TYPE:int
Identifier:num
RP:)
LBRACKET:{
VarDeclarationList:
VarDeclarationList:
VarDeclaration:
TYPE:int
Identifier:count01
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:count02
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:aux03
SEMICOLON:;
StatementList:
StatementList:
StatementList:
AssignmentStatement:
Identifier:count01
EQUALS:=
INTEGER:0
SEMICOLON:;
AssignmentStatement:
Identifier:count02
EQUALS:=
INTEGER:0
SEMICOLON:;
AssignmentStatement:
Identifier:aux03
EQUALS:=
MinusExpression:
Identifier:num
MINUS:-
INTEGER:1
SEMICOLON:;
WHILEStatement:
WHILE:while
LP:(
LESSERExpression:
Identifier:count02
LESSER:<
Identifier:aux03
RP:)
Statement:
LBRACKET:{
StatementList:
AssignmentStatement:
Identifier:count01
EQUALS:=
PlusExpression:
Identifier:count01
PLUS:+
INTEGER:1
SEMICOLON:;
AssignmentStatement:
Identifier:count02
EQUALS:=
PlusExpression:
Identifier:count02
PLUS:+
INTEGER:2
SEMICOLON:;
RBRACKET:}
:return
Identifier:count01
SEMICOLON:;
RBRACKET:}
MethodDeclaration:
:public
TYPE:boolean
Identifier:Compare
LP:(
ParameterList:
TYPE:int
Identifier:num1
COMMA:,
ParameterList:
TYPE:int
Identifier:num2
RP:)
LBRACKET:{
VarDeclarationList:
VarDeclaration:
TYPE:boolean
Identifier:retval
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:aux02
SEMICOLON:;
StatementList:
StatementList:
AssignmentStatement:
Identifier:retval
EQUALS:=
LITERAL:false
SEMICOLON:;
AssignmentStatement:
Identifier:aux02
EQUALS:=
PlusExpression:
Identifier:num2
PLUS:+
INTEGER:1
SEMICOLON:;
IFStatement:
IF:if
LP:(
LESSERExpression:
Identifier:num1
LESSER:<
Identifier:num2
RP:)
AssignmentStatement:
Identifier:retval
EQUALS:=
LITERAL:false
SEMICOLON:;
ELSE:else
IFStatement:
IF:if
LP:(
NOTExpression:
NOT:!
ParenExpression:
LP:(
LESSERExpression:
Identifier:num1
LESSER:<
Identifier:aux02
RP:)
RP:)
AssignmentStatement:
Identifier:retval
EQUALS:=
LITERAL:false
SEMICOLON:;
ELSE:else
AssignmentStatement:
Identifier:retval
EQUALS:=
LITERAL:true
SEMICOLON:;
:return
Identifier:retval
SEMICOLON:;
RBRACKET:}
MethodDeclaration:
:public
TYPE:int
Identifier:Print
LP:(
RP:)
LBRACKET:{
VarDeclaration:
TYPE:int
Identifier:j
SEMICOLON:;
StatementList:
StatementList:
AssignmentStatement:
Identifier:j
EQUALS:=
INTEGER:1
SEMICOLON:;
WHILEStatement:
WHILE:while
LP:(
LESSERExpression:
Identifier:j
LESSER:<
ParenExpression:
LP:(
Identifier:size
RP:)
RP:)
Statement:
LBRACKET:{
StatementList:
PrintStatement:
PRINT:System.out.println
LP:(
VectorAccessExpression:
Identifier:number
LSQUAREP:[
Identifier:j
RSQUAREP:]
RP:)
SEMICOLON:;
AssignmentStatement:
Identifier:j
EQUALS:=
PlusExpression:
Identifier:j
PLUS:+
INTEGER:1
SEMICOLON:;
RBRACKET:}
PrintStatement:
PRINT:System.out.println
LP:(
INTEGER:99999
RP:)
SEMICOLON:;
:return
INTEGER:0
SEMICOLON:;
RBRACKET:}
MethodDeclaration:
:public
TYPE:int
Identifier:Init
LP:(
ParameterList:
TYPE:int
Identifier:sz
RP:)
LBRACKET:{
VarDeclarationList:
VarDeclarationList:
VarDeclarationList:
VarDeclaration:
TYPE:int
Identifier:j
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:k
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:aux02
SEMICOLON:;
VarDeclaration:
TYPE:int
Identifier:aux01
SEMICOLON:;
StatementList:
StatementList:
StatementList:
StatementList:
AssignmentStatement:
Identifier:size
EQUALS:=
Identifier:sz
SEMICOLON:;
AssignmentStatement:
Identifier:number
EQUALS:=
NewVectorExpression:
NEW:new
INT:int
LSQUAREP:[
Identifier:sz
RSQUAREP:]
SEMICOLON:;
AssignmentStatement:
Identifier:j
EQUALS:=
INTEGER:1
SEMICOLON:;
AssignmentStatement:
Identifier:k
EQUALS:=
PlusExpression:
Identifier:size
PLUS:+
INTEGER:1
SEMICOLON:;
WHILEStatement:
WHILE:while
LP:(
LESSERExpression:
Identifier:j
LESSER:<
ParenExpression:
LP:(
Identifier:size
RP:)
RP:)
Statement:
LBRACKET:{
StatementList:
StatementList:
StatementList:
StatementList:
AssignmentStatement:
Identifier:aux01
EQUALS:=
MultExpression:
INTEGER:2
MULTOP:*
Identifier:j
SEMICOLON:;
AssignmentStatement:
Identifier:aux02
EQUALS:=
MinusExpression:
Identifier:k
MINUS:-
INTEGER:3
SEMICOLON:;
VectorAssignmentStatement:
Identifier:number
LSQUAREP:[
Identifier:j
RSQUAREP:]
EQUALS:=
PlusExpression:
Identifier:aux01
PLUS:+
Identifier:aux02
SEMICOLON:;
AssignmentStatement:
Identifier:j
EQUALS:=
PlusExpression:
Identifier:j
PLUS:+
INTEGER:1
SEMICOLON:;
AssignmentStatement:
Identifier:k
EQUALS:=
MinusExpression:
Identifier:k
MINUS:-
INTEGER:1
SEMICOLON:;
RBRACKET:}
:return
INTEGER:0
SEMICOLON:;
RBRACKET:}
RBRACKET:}
